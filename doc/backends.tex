% !TEX root = SoLoud.tex
%===============================================================================

\chapter{Back-ends}

SoLoud needs a back-end to play audio out. SoLoud ships with a bunch of back-ends with various levels of stability and latency. Creating new back-ends is relatively simple.

SoLoud speaks with the back-end with only a couple of functions, in addition to the optional mutex function pointers.

Studying the existing back-end implementations' source code, in addition to this page, will help creating new ones.

\section{Soloud.init()}

The back-end should call Soloud.init() once it knows what it can do.

\begin{lstlisting}{frame=single, framerule=1pt}
void init(int aSamplerate, // Sample rate, in hz
          int aBufferSize, // Buffer size, in samples
          int aFlags);     // Flags
\end{lstlisting}

The channels and flags most likely come directly from the application, while sample rate and buffer size may depend on how the back-end does things. The buffer size should be the maximum number of samples the back-end requests on one call. Making it bigger doesn't affect latency, but causes SoLoud to create too big internal mixing buffers.

\section{Soloud.mix()}

The back-end can call the mix function to request a number of stereo samples from SoLoud. The samples will be in float format, and the back-end is responsible for converting them to the desired output format.

\begin{lstlisting}{frame=single, framerule=1pt}
void mix(float *aBuffer, // Destination buffer
         int aSamples);  // Number of requested stereo samples
\end{lstlisting}

If the number of samples exceeds the buffer size set at init, the result is undefined (most likely a crash).

\section{Soloud.mBackendData}

This void pointer is free for the back-end to use in any way it wants. It may be a convenient place to store any buffers and other information it needs to keep around.

\section{Soloud.mLockMutexFunc / Soloud.mUnlockMutexFunc}

These function pointers point to functions which should lock and unlock a mutex. If they are left as NULL, they will not be called.

If they're not implemented, SoLoud will not be thread safe. This means that some shared resources, such as the channel data, may be accessed by several threads at the same time. In the worst case one thread may delete an object while another is accessing it.

\section{Soloud.mMutex}

Pointer to mutex data. The pointer is also passed to the lock/unlock mutex functions as a parameter.

\section{Soloud.mBackendCleanupFunc}

This function pointer is used by SoLoud to signal the back-end to perform cleanup; stop any threads, free any resources, etc. If NULL, not called, but may result in resource leaks and quite possibly crashes.

\section{Different back-ends}

This is a non-exhaustive list of back-ends and notes regarding them.

\begin{itemize}
\item SDL 
\begin{itemize}
\item Most tested, primary development platform
\item Cross-platform
\item Low latency
\end{itemize}
\item PortAudio
\begin{itemize}
\item Cross-platform
\item Low latency
\end{itemize}
\item Windows multimedia
\begin{itemize}
\item Simplest back-end for windows-only programs
\end{itemize}
\item oss (/dev/dsp)
\begin{itemize}
\item Simplest back-end for linux-only programs
\item Experimental
\end{itemize}
\item OpenAL
\begin{itemize}
\item Experimental
\item High latency; if this is your only option, you're probably better off using OpenAL directly.
\end{itemize}
\item WASAPI
\begin{itemize}
\item Experimental
\end{itemize}
\item XAudio2
\begin{itemize}
\item Experimental
\end{itemize}
\end{itemize}